{#-
  Domain Events Template for ggen sync

  Generates domain event types following DDD patterns with frozen sections
  for custom code preservation during regeneration.

  Domain events are immutable records of what happened in the domain.
-#}
---
to: "src/generated/domain/events/{{ name | snake }}_events.rs"
vars:
  name: "{{ name }}"
  description: "{{ description | default(value='Domain events') }}"
freeze_policy: "checksum"
freeze_slots_dir: "src/generated/.ggen/freeze"
---
//! {{ name | title }} Domain Events
//!
//! {{ description }}
//!
//! Generated by ggen sync on {{ "now" | date(format="%Y-%m-%d %H:%M:%S") }}
//! DO NOT EDIT outside of frozen sections - changes will be overwritten.

use chrono::{DateTime, Utc};
use serde::{Deserialize, Serialize};
use crate::generated::domain::entities::{{ name | pascal }}Id;

/// Trait for all domain events
pub trait DomainEvent: Send + Sync + Clone {
    /// Get the event type name
    fn event_type(&self) -> &'static str;

    /// Get when the event occurred
    fn occurred_at(&self) -> DateTime<Utc>;

    /// Get the aggregate ID this event belongs to
    fn aggregate_id(&self) -> &str;

    /// Get the event version (for schema evolution)
    fn version(&self) -> u32 {
        1
    }
}

/// Events for {{ name | title }} aggregate
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(tag = "type", rename_all = "snake_case")]
pub enum {{ name | pascal }}Event {
    /// {{ name | title }} was created
    Created {
        id: {{ name | pascal }}Id,
        created_at: DateTime<Utc>,
    },

    /// {{ name | title }} was updated
    Updated {
        id: {{ name | pascal }}Id,
        updated_at: DateTime<Utc>,
    },

    /// {{ name | title }} was deleted
    Deleted {
        id: {{ name | pascal }}Id,
        deleted_at: DateTime<Utc>,
    },

    // === ggen:frozen:start:event_variants ===
    // Custom event variants - preserved during regeneration
    //
    // Example custom events:
    // /// Name was changed
    // NameChanged {
    //     id: {{ name | pascal }}Id,
    //     old_name: String,
    //     new_name: String,
    //     changed_at: DateTime<Utc>,
    // },
    //
    // /// Status was updated
    // StatusChanged {
    //     id: {{ name | pascal }}Id,
    //     old_status: String,
    //     new_status: String,
    //     changed_at: DateTime<Utc>,
    // },
    // === ggen:frozen:end:event_variants ===
}

impl DomainEvent for {{ name | pascal }}Event {
    fn event_type(&self) -> &'static str {
        match self {
            Self::Created { .. } => "{{ name | snake }}_created",
            Self::Updated { .. } => "{{ name | snake }}_updated",
            Self::Deleted { .. } => "{{ name | snake }}_deleted",
            // === ggen:frozen:start:event_type_match ===
            // Custom event type matching - preserved during regeneration
            // Add match arms for custom events here
            // === ggen:frozen:end:event_type_match ===
        }
    }

    fn occurred_at(&self) -> DateTime<Utc> {
        match self {
            Self::Created { created_at, .. } => *created_at,
            Self::Updated { updated_at, .. } => *updated_at,
            Self::Deleted { deleted_at, .. } => *deleted_at,
            // === ggen:frozen:start:occurred_at_match ===
            // Custom occurred_at matching - preserved during regeneration
            // === ggen:frozen:end:occurred_at_match ===
        }
    }

    fn aggregate_id(&self) -> &str {
        match self {
            Self::Created { id, .. } => id.as_str(),
            Self::Updated { id, .. } => id.as_str(),
            Self::Deleted { id, .. } => id.as_str(),
            // === ggen:frozen:start:aggregate_id_match ===
            // Custom aggregate_id matching - preserved during regeneration
            // === ggen:frozen:end:aggregate_id_match ===
        }
    }
}

impl {{ name | pascal }}Event {
    /// Check if this is a creation event
    pub fn is_creation(&self) -> bool {
        matches!(self, Self::Created { .. })
    }

    /// Check if this is a deletion event
    pub fn is_deletion(&self) -> bool {
        matches!(self, Self::Deleted { .. })
    }

    // === ggen:frozen:start:custom_methods ===
    // Custom event methods - preserved during regeneration
    //
    // Example:
    // pub fn is_significant_change(&self) -> bool {
    //     matches!(self, Self::StatusChanged { .. } | Self::NameChanged { .. })
    // }
    // === ggen:frozen:end:custom_methods ===
}

/// Event envelope for persistence and messaging
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct EventEnvelope<E> {
    /// Unique event ID
    pub event_id: String,
    /// The event payload
    pub payload: E,
    /// Correlation ID for tracing
    pub correlation_id: Option<String>,
    /// Causation ID (ID of event that caused this one)
    pub causation_id: Option<String>,
    /// Metadata
    pub metadata: std::collections::HashMap<String, String>,
}

impl<E: DomainEvent> EventEnvelope<E> {
    /// Create a new event envelope
    pub fn new(payload: E) -> Self {
        Self {
            event_id: uuid::Uuid::new_v4().to_string(),
            payload,
            correlation_id: None,
            causation_id: None,
            metadata: std::collections::HashMap::new(),
        }
    }

    /// Add correlation ID
    pub fn with_correlation_id(mut self, id: impl Into<String>) -> Self {
        self.correlation_id = Some(id.into());
        self
    }

    /// Add causation ID
    pub fn with_causation_id(mut self, id: impl Into<String>) -> Self {
        self.causation_id = Some(id.into());
        self
    }

    /// Add metadata
    pub fn with_metadata(mut self, key: impl Into<String>, value: impl Into<String>) -> Self {
        self.metadata.insert(key.into(), value.into());
        self
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_event_serialization() {
        let event = {{ name | pascal }}Event::Created {
            id: {{ name | pascal }}Id::from("test-id"),
            created_at: Utc::now(),
        };

        let json = serde_json::to_string(&event).expect("should serialize");
        let deserialized: {{ name | pascal }}Event = serde_json::from_str(&json).expect("should deserialize");

        assert_eq!(event.event_type(), deserialized.event_type());
    }

    // === ggen:frozen:start:tests ===
    // Custom tests - preserved during regeneration
    // === ggen:frozen:end:tests ===
}
