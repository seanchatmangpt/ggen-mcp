{#-
  Aggregate Root Template for ggen sync

  Generates an aggregate root following DDD patterns with frozen sections
  for custom code preservation during regeneration.

  Aggregates define transactional consistency boundaries and emit domain events.
-#}
---
to: "src/generated/domain/aggregates/{{ name | snake }}_aggregate.rs"
vars:
  name: "{{ name }}"
  description: "{{ description | default(value='Domain aggregate') }}"
freeze_policy: "checksum"
freeze_slots_dir: "src/generated/.ggen/freeze"
---
//! {{ name | title }} Aggregate
//!
//! {{ description }}
//!
//! Generated by ggen sync on {{ "now" | date(format="%Y-%m-%d %H:%M:%S") }}
//! DO NOT EDIT outside of frozen sections - changes will be overwritten.

use crate::generated::domain::entities::{{ name | pascal }};
use crate::generated::domain::events::{{ name | pascal }}Event;
use std::collections::VecDeque;

/// {{ name | title }} Aggregate Root
///
/// Defines the consistency boundary for {{ name | title }} and related entities.
/// All modifications must go through the aggregate root to maintain invariants.
#[derive(Debug, Clone)]
pub struct {{ name | pascal }}Aggregate {
    /// The root entity
    root: {{ name | pascal }},
    /// Pending domain events to be published
    pending_events: VecDeque<{{ name | pascal }}Event>,
    /// Version for optimistic concurrency
    version: u64,
}

impl {{ name | pascal }}Aggregate {
    /// Create a new aggregate from an entity
    pub fn new(root: {{ name | pascal }}) -> Self {
        Self {
            root,
            pending_events: VecDeque::new(),
            version: 0,
        }
    }

    /// Create a new aggregate and record a creation event
    pub fn create(root: {{ name | pascal }}) -> Self {
        let mut aggregate = Self::new(root);
        aggregate.record_event({{ name | pascal }}Event::Created {
            id: aggregate.root.id.clone(),
            created_at: chrono::Utc::now(),
        });
        aggregate
    }

    /// Get a reference to the root entity
    pub fn root(&self) -> &{{ name | pascal }} {
        &self.root
    }

    /// Get the aggregate version (for optimistic locking)
    pub fn version(&self) -> u64 {
        self.version
    }

    /// Set the version (typically used when loading from storage)
    pub fn set_version(&mut self, version: u64) {
        self.version = version;
    }

    /// Take all pending events (consuming them)
    pub fn take_events(&mut self) -> Vec<{{ name | pascal }}Event> {
        self.pending_events.drain(..).collect()
    }

    /// Check if there are pending events
    pub fn has_pending_events(&self) -> bool {
        !self.pending_events.is_empty()
    }

    /// Record a domain event
    fn record_event(&mut self, event: {{ name | pascal }}Event) {
        self.pending_events.push_back(event);
    }

    /// Increment the version
    fn increment_version(&mut self) {
        self.version += 1;
    }

    // === ggen:frozen:start:aggregate_methods ===
    // Custom aggregate methods - preserved during regeneration
    //
    // Add methods that modify the aggregate state here.
    // Each method should:
    // 1. Validate business rules
    // 2. Make the change
    // 3. Record appropriate domain events
    // 4. Increment version if needed
    //
    // Example:
    // pub fn update_name(&mut self, new_name: String) -> Result<(), AggregateError> {
    //     // Validate
    //     if new_name.is_empty() {
    //         return Err(AggregateError::InvalidName);
    //     }
    //
    //     // Record old value for event
    //     let old_name = self.root.name.clone();
    //
    //     // Make change
    //     self.root.name = new_name.clone();
    //     self.root.touch();
    //
    //     // Record event
    //     self.record_event({{ name | pascal }}Event::NameUpdated {
    //         id: self.root.id.clone(),
    //         old_name,
    //         new_name,
    //         updated_at: chrono::Utc::now(),
    //     });
    //
    //     // Increment version
    //     self.increment_version();
    //
    //     Ok(())
    // }
    // === ggen:frozen:end:aggregate_methods ===
}

/// Errors that can occur when modifying the aggregate
#[derive(Debug, Clone, thiserror::Error)]
pub enum AggregateError {
    #[error("Invalid operation: {0}")]
    InvalidOperation(String),

    #[error("Invariant violated: {0}")]
    InvariantViolated(String),

    #[error("Concurrency conflict: expected version {expected}, got {actual}")]
    ConcurrencyConflict { expected: u64, actual: u64 },

    // === ggen:frozen:start:error_variants ===
    // Custom error variants - preserved during regeneration
    // === ggen:frozen:end:error_variants ===
}

/// Trait for applying events to aggregate state (Event Sourcing support)
pub trait EventSourced {
    type Event;

    /// Apply an event to update aggregate state
    fn apply(&mut self, event: &Self::Event);

    /// Replay a sequence of events to rebuild state
    fn replay(&mut self, events: impl IntoIterator<Item = Self::Event>) {
        for event in events {
            self.apply(&event);
        }
    }
}

impl EventSourced for {{ name | pascal }}Aggregate {
    type Event = {{ name | pascal }}Event;

    fn apply(&mut self, event: &Self::Event) {
        // === ggen:frozen:start:event_application ===
        // Custom event application logic - preserved during regeneration
        //
        // Example:
        // match event {
        //     {{ name | pascal }}Event::Created { .. } => {
        //         // Nothing to do, initial state is set in constructor
        //     }
        //     {{ name | pascal }}Event::NameUpdated { new_name, .. } => {
        //         self.root.name = new_name.clone();
        //     }
        // }
        let _ = event; // Suppress unused warning until implemented
        // === ggen:frozen:end:event_application ===

        self.increment_version();
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    // === ggen:frozen:start:tests ===
    // Custom tests - preserved during regeneration
    //
    // #[test]
    // fn test_aggregate_creation_emits_event() {
    //     // Test that creating an aggregate emits the Created event
    // }
    //
    // #[test]
    // fn test_version_increments_on_change() {
    //     // Test that version increments when aggregate changes
    // }
    // === ggen:frozen:end:tests ===
}
