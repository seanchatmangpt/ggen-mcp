{#-
  Value Object Template for ggen sync

  Generates an immutable value object following DDD patterns with frozen sections
  for custom code preservation during regeneration.

  Value objects are immutable, have no identity, and are compared by their attributes.
-#}
---
to: "src/generated/domain/value_objects/{{ name | snake }}.rs"
vars:
  name: "{{ name }}"
  description: "{{ description | default(value='Domain value object') }}"
freeze_policy: "checksum"
freeze_slots_dir: "src/generated/.ggen/freeze"
---
//! {{ name | title }} Value Object
//!
//! {{ description }}
//!
//! Generated by ggen sync on {{ "now" | date(format="%Y-%m-%d %H:%M:%S") }}
//! DO NOT EDIT outside of frozen sections - changes will be overwritten.

use serde::{Deserialize, Serialize};
use std::fmt;

/// {{ name | title }} Value Object
///
/// {{ description }}
///
/// ## Characteristics
/// - Immutable: Cannot be changed after creation
/// - No Identity: Compared by attribute values, not identity
/// - Self-Validating: Validates invariants on construction
#[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]
pub struct {{ name | pascal }} {
    {% for field in fields -%}
    {{ field.name | snake }}: {{ field.type }},
    {% endfor -%}
}

impl {{ name | pascal }} {
    /// Create a new {{ name | title }}
    ///
    /// Returns an error if validation fails.
    pub fn new(
        {% for field in fields -%}
        {{ field.name | snake }}: {{ field.type }},
        {% endfor -%}
    ) -> Result<Self, {{ name | pascal }}Error> {
        let value = Self {
            {% for field in fields -%}
            {{ field.name | snake }},
            {% endfor -%}
        };
        value.validate()?;
        Ok(value)
    }

    /// Create without validation (use with caution, only for trusted data)
    ///
    /// # Safety
    /// Caller must ensure the data is valid.
    pub fn new_unchecked(
        {% for field in fields -%}
        {{ field.name | snake }}: {{ field.type }},
        {% endfor -%}
    ) -> Self {
        Self {
            {% for field in fields -%}
            {{ field.name | snake }},
            {% endfor -%}
        }
    }

    {% for field in fields -%}
    /// Get the {{ field.name | snake }} value
    pub fn {{ field.name | snake }}(&self) -> {% if field.type == "String" %}&str{% else %}{{ field.type }}{% endif %} {
        {% if field.type == "String" %}&self.{{ field.name | snake }}{% else %}self.{{ field.name | snake }}{% endif %}
    }

    {% endfor -%}

    /// Validate the value object invariants
    fn validate(&self) -> Result<(), {{ name | pascal }}Error> {
        // === ggen:frozen:start:validation ===
        // Custom validation logic - preserved during regeneration
        //
        // Example validation:
        // if self.some_field.is_empty() {
        //     return Err({{ name | pascal }}Error::InvalidField("some_field cannot be empty"));
        // }
        // === ggen:frozen:end:validation ===

        Ok(())
    }

    // === ggen:frozen:start:custom_methods ===
    // Custom methods - preserved during regeneration
    //
    // Value objects can have behavior, but methods should return new instances
    // rather than modifying self (immutability).
    //
    // Example:
    // pub fn with_updated_field(&self, new_value: String) -> Result<Self, {{ name | pascal }}Error> {
    //     Self::new(new_value, self.other_field.clone())
    // }
    // === ggen:frozen:end:custom_methods ===
}

impl fmt::Display for {{ name | pascal }} {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        // === ggen:frozen:start:display ===
        // Custom display implementation - preserved during regeneration
        write!(f, "{{ name | pascal }}({% for field in fields %}{{ field.name | snake }}: {:?}{% if not loop.last %}, {% endif %}{% endfor %})"{% for field in fields %}, self.{{ field.name | snake }}{% endfor %})
        // === ggen:frozen:end:display ===
    }
}

/// Errors for {{ name | title }} value object
#[derive(Debug, Clone, thiserror::Error)]
pub enum {{ name | pascal }}Error {
    #[error("Invalid field: {0}")]
    InvalidField(&'static str),

    #[error("Validation failed: {0}")]
    ValidationFailed(String),

    // === ggen:frozen:start:error_variants ===
    // Custom error variants - preserved during regeneration
    // === ggen:frozen:end:error_variants ===
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_equality() {
        // Value objects with same attributes should be equal
        // (This test will be filled in when fields are defined)
    }

    #[test]
    fn test_hash_consistency() {
        // Equal value objects should have the same hash
        // (This test will be filled in when fields are defined)
    }

    // === ggen:frozen:start:tests ===
    // Custom tests - preserved during regeneration
    // === ggen:frozen:end:tests ===
}
