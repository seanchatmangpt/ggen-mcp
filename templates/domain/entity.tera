{#-
  Entity Template for ggen sync

  Generates a domain entity following DDD patterns with frozen sections
  for custom code preservation during regeneration.

  Frontmatter Configuration:
  - to: Output file path
  - vars: Template variables
  - freeze_policy: "checksum" | "timestamp" | "manual"
  - freeze_slots_dir: Directory for frozen section storage

  Usage:
    ggen sync --template templates/domain/entity.tera
-#}
---
to: "src/generated/domain/entities/{{ name | snake }}.rs"
vars:
  name: "{{ name }}"
  description: "{{ description | default(value='Domain entity') }}"
prefixes:
  ex: "http://ggen.dev/domain/"
  rdfs: "http://www.w3.org/2000/01/rdf-schema#"
freeze_policy: "checksum"
freeze_slots_dir: "src/generated/.ggen/freeze"
---
//! {{ name | title }} Entity
//!
//! {{ description }}
//!
//! Generated by ggen sync on {{ "now" | date(format="%Y-%m-%d %H:%M:%S") }}
//! DO NOT EDIT outside of frozen sections - changes will be overwritten.

use serde::{Deserialize, Serialize};
use std::fmt;

/// Unique identifier for {{ name | title }}
#[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]
pub struct {{ name | pascal }}Id(String);

impl {{ name | pascal }}Id {
    /// Create a new {{ name | title }} ID
    pub fn new(id: impl Into<String>) -> Self {
        Self(id.into())
    }

    /// Get the inner string value
    pub fn as_str(&self) -> &str {
        &self.0
    }

    /// Generate a new unique ID
    pub fn generate() -> Self {
        Self(uuid::Uuid::new_v4().to_string())
    }
}

impl fmt::Display for {{ name | pascal }}Id {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        write!(f, "{}", self.0)
    }
}

impl From<String> for {{ name | pascal }}Id {
    fn from(s: String) -> Self {
        Self::new(s)
    }
}

impl From<&str> for {{ name | pascal }}Id {
    fn from(s: &str) -> Self {
        Self::new(s)
    }
}

/// {{ name | title }} Entity
///
/// {{ description }}
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct {{ name | pascal }} {
    /// Unique identifier
    pub id: {{ name | pascal }}Id,
    {% for property in properties -%}
    /// {{ property.description | default(value=property.name) }}
    pub {{ property.name | snake }}: {{ property.type }},
    {% endfor -%}
    /// Creation timestamp
    pub created_at: chrono::DateTime<chrono::Utc>,
    /// Last update timestamp
    pub updated_at: chrono::DateTime<chrono::Utc>,
}

impl {{ name | pascal }} {
    /// Create a new {{ name | title }}
    pub fn new(
        {% for property in properties -%}
        {{ property.name | snake }}: {{ property.type }},
        {% endfor -%}
    ) -> Self {
        let now = chrono::Utc::now();
        Self {
            id: {{ name | pascal }}Id::generate(),
            {% for property in properties -%}
            {{ property.name | snake }},
            {% endfor -%}
            created_at: now,
            updated_at: now,
        }
    }

    /// Create with a specific ID (for reconstruction from storage)
    pub fn with_id(
        id: {{ name | pascal }}Id,
        {% for property in properties -%}
        {{ property.name | snake }}: {{ property.type }},
        {% endfor -%}
        created_at: chrono::DateTime<chrono::Utc>,
        updated_at: chrono::DateTime<chrono::Utc>,
    ) -> Self {
        Self {
            id,
            {% for property in properties -%}
            {{ property.name | snake }},
            {% endfor -%}
            created_at,
            updated_at,
        }
    }

    /// Validate the entity state
    pub fn validate(&self) -> Result<(), ValidationError> {
        // === ggen:frozen:start:validation ===
        // Custom validation logic - preserved during regeneration
        // Add your validation rules here:
        //
        // if self.name.is_empty() {
        //     return Err(ValidationError::EmptyName);
        // }
        // === ggen:frozen:end:validation ===

        Ok(())
    }

    /// Mark the entity as updated
    pub fn touch(&mut self) {
        self.updated_at = chrono::Utc::now();
    }

    // === ggen:frozen:start:custom_methods ===
    // Custom methods - preserved during regeneration
    //
    // Add your custom methods here. This section will NOT be overwritten
    // when ggen sync regenerates this file.
    //
    // Example:
    // pub fn calculate_something(&self) -> u32 {
    //     // Your custom logic
    //     0
    // }
    // === ggen:frozen:end:custom_methods ===
}

impl PartialEq for {{ name | pascal }} {
    fn eq(&self, other: &Self) -> bool {
        // Entities are equal if they have the same identity
        self.id == other.id
    }
}

impl Eq for {{ name | pascal }} {}

impl std::hash::Hash for {{ name | pascal }} {
    fn hash<H: std::hash::Hasher>(&self, state: &mut H) {
        self.id.hash(state);
    }
}

/// Validation errors for {{ name | title }}
#[derive(Debug, Clone, thiserror::Error)]
pub enum ValidationError {
    #[error("Validation failed: {0}")]
    Invalid(String),

    // === ggen:frozen:start:error_variants ===
    // Custom error variants - preserved during regeneration
    // Add your error variants here:
    //
    // #[error("Name cannot be empty")]
    // EmptyName,
    // === ggen:frozen:end:error_variants ===
}

/// Builder for {{ name | title }}
#[derive(Debug, Default)]
pub struct {{ name | pascal }}Builder {
    {% for property in properties -%}
    {{ property.name | snake }}: Option<{{ property.type }}>,
    {% endfor -%}
}

impl {{ name | pascal }}Builder {
    pub fn new() -> Self {
        Self::default()
    }

    {% for property in properties -%}
    pub fn {{ property.name | snake }}(mut self, value: {{ property.type }}) -> Self {
        self.{{ property.name | snake }} = Some(value);
        self
    }

    {% endfor -%}
    pub fn build(self) -> Result<{{ name | pascal }}, BuilderError> {
        Ok({{ name | pascal }}::new(
            {% for property in properties -%}
            self.{{ property.name | snake }}.ok_or(BuilderError::MissingField("{{ property.name | snake }}"))?,
            {% endfor -%}
        ))
    }
}

#[derive(Debug, Clone, thiserror::Error)]
pub enum BuilderError {
    #[error("Missing required field: {0}")]
    MissingField(&'static str),
}

#[cfg(test)]
mod tests {
    use super::*;

    // === ggen:frozen:start:tests ===
    // Custom tests - preserved during regeneration
    //
    // #[test]
    // fn test_custom_behavior() {
    //     // Your test
    // }
    // === ggen:frozen:end:tests ===
}
