---
to: "generated/resources/{{ resource_name | snake_case }}.rs"
vars:
  resource_name: string
  description: string
  uri_template: string
  mime_type: string
  has_caching: boolean
  has_subscriptions: boolean
  cache_ttl_secs: number
  fields: array
---
{#- Validate required variables - ensure resource_name is provided -#}
{%- if not resource_name -%}
{# ERROR: resource_name is required for resource handler generation -#}
//! ERROR: Missing required variable 'resource_name'
{%- else -%}
//! MCP Resource Handler: {{ resource_name | snake_case }}
//!
//! {{ description }}
//!
//! URI Template: {{ uri_template | default(value=resource_name | snake_case ~ ":///{id}") }}
//! MIME Type: {{ mime_type | default(value="application/json") }}
//! Generated by ggen from ontology specification
//!
//! IMPORTANT: Sections marked with `# frozen` / `# end frozen` preserve your
//! custom code during regeneration. Edit only within frozen sections.

use anyhow::{Result, Context, anyhow};
use serde::{Deserialize, Serialize};
use std::sync::Arc;
{% if has_caching %}
use std::time::{Duration, Instant};
use tokio::sync::RwLock;
use std::collections::HashMap;
{% endif %}
use crate::state::AppState;

{% if has_caching %}
/// Cache TTL for {{ resource_name | snake_case }} resources
const CACHE_TTL: Duration = Duration::from_secs({{ cache_ttl_secs | default(value=300) }});
{% endif %}

// ============================================================================
// RESOURCE URI
// ============================================================================

/// URI scheme for {{ resource_name | pascal_case }} resources
pub const URI_SCHEME: &str = "{{ resource_name | kebab_case | default(value=resource_name | snake_case) }}";

/// Parse a {{ resource_name | pascal_case }} resource URI
///
/// Expected format: `{{ uri_template | default(value=resource_name | snake_case ~ ":///{id}") }}`
pub fn parse_uri(uri: &str) -> Result<{{ resource_name | pascal_case }}Uri> {
    let uri = uri
        .strip_prefix(&format!("{}://", URI_SCHEME))
        .ok_or_else(|| anyhow!("Invalid URI scheme, expected {}", URI_SCHEME))?;

    // # frozen id="uri_parsing"
    // Implement custom URI parsing logic here - it will be preserved during regeneration
    //
    // Example:
    // let parts: Vec<&str> = uri.split('/').collect();
    // let id = parts.get(0).ok_or_else(|| anyhow!("Missing resource ID"))?;

    let id = uri.to_string();

    Ok({{ resource_name | pascal_case }}Uri {
        id,
        // Add additional URI components as needed
    })
    // # end frozen
}

/// Parsed URI components for {{ resource_name | pascal_case }}
#[derive(Debug, Clone)]
pub struct {{ resource_name | pascal_case }}Uri {
    /// Resource identifier
    pub id: String,

    // # frozen id="uri_components"
    // Add additional URI components here - they will be preserved during regeneration
    // # end frozen
}

impl {{ resource_name | pascal_case }}Uri {
    /// Convert back to URI string
    pub fn to_uri_string(&self) -> String {
        format!("{}://{}", URI_SCHEME, self.id)
    }
}

// ============================================================================
// RESOURCE DEFINITION
// ============================================================================

/// {{ resource_name | pascal_case }} resource descriptor
#[derive(Debug, Clone, Serialize)]
pub struct {{ resource_name | pascal_case }}Resource {
    /// Resource URI
    pub uri: String,

    /// Human-readable name
    pub name: String,

    /// Resource description
    #[serde(skip_serializing_if = "Option::is_none")]
    pub description: Option<String>,

    /// MIME type of the resource content
    pub mime_type: String,

    {% for field in fields %}
    /// {{ field.description | default(value="Field") }}
    {% if field.optional | default(value=false) %}
    #[serde(skip_serializing_if = "Option::is_none")]
    pub {{ field.name | snake_case }}: Option<{{ field.rust_type | default(value="String") }}>,
    {% else %}
    pub {{ field.name | snake_case }}: {{ field.rust_type | default(value="String") }},
    {% endif %}
    {% endfor %}

    // # frozen id="additional_resource_fields"
    // Add custom resource fields here - they will be preserved during regeneration
    // # end frozen
}

/// {{ resource_name | pascal_case }} resource content
#[derive(Debug, Clone, Serialize)]
pub struct {{ resource_name | pascal_case }}Content {
    /// The actual resource data
    pub data: {{ resource_name | pascal_case }}Data,

    /// Content metadata
    pub metadata: {{ resource_name | pascal_case }}Metadata,
}

/// Core data for {{ resource_name | pascal_case }} resource
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct {{ resource_name | pascal_case }}Data {
    {% for field in fields %}
    /// {{ field.description | default(value="Field") }}
    {% if field.optional | default(value=false) %}
    #[serde(skip_serializing_if = "Option::is_none")]
    pub {{ field.name | snake_case }}: Option<{{ field.rust_type | default(value="String") }}>,
    {% else %}
    pub {{ field.name | snake_case }}: {{ field.rust_type | default(value="String") }},
    {% endif %}
    {% endfor %}

    // # frozen id="data_fields"
    // Add custom data fields here - they will be preserved during regeneration
    // # end frozen
}

/// Metadata about the resource
#[derive(Debug, Clone, Serialize)]
pub struct {{ resource_name | pascal_case }}Metadata {
    /// When the resource was last modified
    pub last_modified: Option<String>,

    /// Resource version/ETag
    pub etag: Option<String>,

    /// Content size in bytes
    pub size_bytes: Option<usize>,

    // # frozen id="metadata_fields"
    // Add custom metadata fields here - they will be preserved during regeneration
    // # end frozen
}

{% if has_caching %}
// ============================================================================
// CACHING
// ============================================================================

/// Cached resource entry
#[derive(Debug, Clone)]
struct CacheEntry {
    content: {{ resource_name | pascal_case }}Content,
    cached_at: Instant,
}

impl CacheEntry {
    fn is_expired(&self) -> bool {
        self.cached_at.elapsed() > CACHE_TTL
    }
}

/// Resource cache for {{ resource_name | pascal_case }}
pub struct {{ resource_name | pascal_case }}Cache {
    entries: RwLock<HashMap<String, CacheEntry>>,
}

impl Default for {{ resource_name | pascal_case }}Cache {
    fn default() -> Self {
        Self::new()
    }
}

impl {{ resource_name | pascal_case }}Cache {
    /// Create a new cache
    pub fn new() -> Self {
        Self {
            entries: RwLock::new(HashMap::new()),
        }
    }

    /// Get a cached entry if valid
    pub async fn get(&self, uri: &str) -> Option<{{ resource_name | pascal_case }}Content> {
        let entries = self.entries.read().await;
        entries.get(uri).and_then(|entry| {
            if entry.is_expired() {
                None
            } else {
                Some(entry.content.clone())
            }
        })
    }

    /// Store an entry in the cache
    pub async fn put(&self, uri: String, content: {{ resource_name | pascal_case }}Content) {
        let mut entries = self.entries.write().await;
        entries.insert(uri, CacheEntry {
            content,
            cached_at: Instant::now(),
        });
    }

    /// Invalidate a cached entry
    pub async fn invalidate(&self, uri: &str) {
        let mut entries = self.entries.write().await;
        entries.remove(uri);
    }

    /// Clear all cached entries
    pub async fn clear(&self) {
        let mut entries = self.entries.write().await;
        entries.clear();
    }

    /// Remove expired entries
    pub async fn evict_expired(&self) {
        let mut entries = self.entries.write().await;
        entries.retain(|_, entry| !entry.is_expired());
    }
}
{% endif %}

{% if has_subscriptions %}
// ============================================================================
// SUBSCRIPTIONS
// ============================================================================

/// Subscription to {{ resource_name | pascal_case }} resource changes
#[derive(Debug, Clone)]
pub struct {{ resource_name | pascal_case }}Subscription {
    /// Subscription ID
    pub id: String,

    /// URI pattern to subscribe to (supports wildcards)
    pub uri_pattern: String,

    /// Callback for resource updates
    pub callback: Arc<dyn Fn({{ resource_name | pascal_case }}Update) + Send + Sync>,
}

/// Resource update notification
#[derive(Debug, Clone, Serialize)]
pub struct {{ resource_name | pascal_case }}Update {
    /// Resource URI that changed
    pub uri: String,

    /// Type of change
    pub change_type: ChangeType,

    /// New content (if applicable)
    pub content: Option<{{ resource_name | pascal_case }}Content>,
}

/// Type of resource change
#[derive(Debug, Clone, Copy, Serialize, Deserialize)]
#[serde(rename_all = "snake_case")]
pub enum ChangeType {
    Created,
    Updated,
    Deleted,
}

/// Subscription manager for {{ resource_name | pascal_case }} resources
pub struct {{ resource_name | pascal_case }}SubscriptionManager {
    subscriptions: RwLock<Vec<{{ resource_name | pascal_case }}Subscription>>,
}

impl Default for {{ resource_name | pascal_case }}SubscriptionManager {
    fn default() -> Self {
        Self::new()
    }
}

impl {{ resource_name | pascal_case }}SubscriptionManager {
    /// Create a new subscription manager
    pub fn new() -> Self {
        Self {
            subscriptions: RwLock::new(Vec::new()),
        }
    }

    /// Subscribe to resource changes
    pub async fn subscribe(
        &self,
        uri_pattern: String,
        callback: Arc<dyn Fn({{ resource_name | pascal_case }}Update) + Send + Sync>,
    ) -> String {
        let id = uuid::Uuid::new_v4().to_string();
        let subscription = {{ resource_name | pascal_case }}Subscription {
            id: id.clone(),
            uri_pattern,
            callback,
        };

        let mut subs = self.subscriptions.write().await;
        subs.push(subscription);
        id
    }

    /// Unsubscribe from resource changes
    pub async fn unsubscribe(&self, subscription_id: &str) {
        let mut subs = self.subscriptions.write().await;
        subs.retain(|s| s.id != subscription_id);
    }

    /// Notify subscribers of a resource change
    pub async fn notify(&self, update: {{ resource_name | pascal_case }}Update) {
        let subs = self.subscriptions.read().await;
        for sub in subs.iter() {
            if matches_pattern(&sub.uri_pattern, &update.uri) {
                (sub.callback)(update.clone());
            }
        }
    }
}

/// Check if a URI matches a subscription pattern
fn matches_pattern(pattern: &str, uri: &str) -> bool {
    // # frozen id="pattern_matching"
    // Implement custom pattern matching logic here - it will be preserved during regeneration
    //
    // Simple wildcard matching (override with more sophisticated matching as needed)
    if pattern == "*" {
        return true;
    }
    if pattern.ends_with('*') {
        let prefix = &pattern[..pattern.len() - 1];
        return uri.starts_with(prefix);
    }
    pattern == uri
    // # end frozen
}
{% endif %}

// ============================================================================
// HANDLER IMPLEMENTATION
// ============================================================================

/// List available {{ resource_name | pascal_case }} resources
pub async fn list_{{ resource_name | snake_case }}_resources(
    state: Arc<AppState>,
) -> Result<Vec<{{ resource_name | pascal_case }}Resource>> {
    // # frozen id="list_implementation"
    // Implement resource listing logic here - it will be preserved during regeneration
    //
    // Example:
    // let resources = state.repository().list_all().await?;
    // Ok(resources.into_iter().map(|r| r.into()).collect())

    let _ = state;
    unimplemented!("Implement list_{{ resource_name | snake_case }}_resources - see frozen section for example")
    // # end frozen
}

/// Read a {{ resource_name | pascal_case }} resource by URI
pub async fn read_{{ resource_name | snake_case }}_resource(
    state: Arc<AppState>,
    uri: &str,
    {% if has_caching %}
    cache: &{{ resource_name | pascal_case }}Cache,
    {% endif %}
) -> Result<{{ resource_name | pascal_case }}Content> {
    let parsed_uri = parse_uri(uri)
        .with_context(|| format!("Failed to parse URI: {}", uri))?;

    {% if has_caching %}
    // Check cache first
    if let Some(cached) = cache.get(uri).await {
        return Ok(cached);
    }
    {% endif %}

    // # frozen id="read_implementation"
    // Implement resource reading logic here - it will be preserved during regeneration
    //
    // Example:
    // let data = state.repository().get(&parsed_uri.id).await?;
    // let content = {{ resource_name | pascal_case }}Content { ... };

    let _ = state;
    let _ = parsed_uri;
    unimplemented!("Implement read_{{ resource_name | snake_case }}_resource - see frozen section for example")
    // # end frozen

    // {% if has_caching %}
    // // Store in cache before returning
    // cache.put(uri.to_string(), content.clone()).await;
    // Ok(content)
    // {% endif %}
}

/// Convert resource content to the specified MIME type
pub fn serialize_content(
    content: &{{ resource_name | pascal_case }}Content,
    mime_type: &str,
) -> Result<Vec<u8>> {
    match mime_type {
        "application/json" => {
            serde_json::to_vec(content)
                .with_context(|| "Failed to serialize to JSON")
        }
        // # frozen id="serialization_formats"
        // Add additional serialization formats here - they will be preserved during regeneration
        //
        // "text/plain" => {
        //     Ok(format!("{:?}", content).into_bytes())
        // }
        // "application/xml" => { ... }
        _ => Err(anyhow!("Unsupported MIME type: {}", mime_type)),
        // # end frozen
    }
}

// ============================================================================
// TESTS
// ============================================================================

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_parse_uri_valid() {
        let uri = format!("{}://test-resource-123", URI_SCHEME);
        let result = parse_uri(&uri);
        assert!(result.is_ok());

        let parsed = result.unwrap();
        assert_eq!(parsed.id, "test-resource-123");
    }

    #[test]
    fn test_parse_uri_invalid_scheme() {
        let uri = "invalid://test-resource";
        let result = parse_uri(uri);
        assert!(result.is_err());
    }

    #[test]
    fn test_uri_roundtrip() {
        let original_id = "roundtrip-test-456";
        let uri_struct = {{ resource_name | pascal_case }}Uri {
            id: original_id.to_string(),
        };

        let uri_string = uri_struct.to_uri_string();
        let parsed = parse_uri(&uri_string).unwrap();

        assert_eq!(parsed.id, original_id);
    }

    {% if has_caching %}
    #[tokio::test]
    async fn test_cache_put_and_get() {
        let cache = {{ resource_name | pascal_case }}Cache::new();
        let uri = "test://cached-resource";

        let content = {{ resource_name | pascal_case }}Content {
            data: {{ resource_name | pascal_case }}Data {
                {% for field in fields %}
                {{ field.name | snake_case }}: {% if field.optional | default(value=false) %}None{% else %}Default::default(){% endif %},
                {% endfor %}
            },
            metadata: {{ resource_name | pascal_case }}Metadata {
                last_modified: None,
                etag: None,
                size_bytes: None,
            },
        };

        cache.put(uri.to_string(), content.clone()).await;

        let retrieved = cache.get(uri).await;
        assert!(retrieved.is_some());
    }

    #[tokio::test]
    async fn test_cache_invalidate() {
        let cache = {{ resource_name | pascal_case }}Cache::new();
        let uri = "test://to-invalidate";

        let content = {{ resource_name | pascal_case }}Content {
            data: {{ resource_name | pascal_case }}Data {
                {% for field in fields %}
                {{ field.name | snake_case }}: {% if field.optional | default(value=false) %}None{% else %}Default::default(){% endif %},
                {% endfor %}
            },
            metadata: {{ resource_name | pascal_case }}Metadata {
                last_modified: None,
                etag: None,
                size_bytes: None,
            },
        };

        cache.put(uri.to_string(), content).await;
        cache.invalidate(uri).await;

        let retrieved = cache.get(uri).await;
        assert!(retrieved.is_none());
    }
    {% endif %}

    {% if has_subscriptions %}
    #[test]
    fn test_pattern_matching_exact() {
        assert!(matches_pattern("test://resource-1", "test://resource-1"));
        assert!(!matches_pattern("test://resource-1", "test://resource-2"));
    }

    #[test]
    fn test_pattern_matching_wildcard() {
        assert!(matches_pattern("*", "test://any-resource"));
        assert!(matches_pattern("test://*", "test://any-resource"));
        assert!(!matches_pattern("other://*", "test://any-resource"));
    }
    {% endif %}

    #[test]
    fn test_serialize_content_json() {
        let content = {{ resource_name | pascal_case }}Content {
            data: {{ resource_name | pascal_case }}Data {
                {% for field in fields %}
                {{ field.name | snake_case }}: {% if field.optional | default(value=false) %}None{% else %}Default::default(){% endif %},
                {% endfor %}
            },
            metadata: {{ resource_name | pascal_case }}Metadata {
                last_modified: None,
                etag: None,
                size_bytes: None,
            },
        };

        let result = serialize_content(&content, "application/json");
        assert!(result.is_ok());
    }

    #[test]
    fn test_serialize_content_unsupported() {
        let content = {{ resource_name | pascal_case }}Content {
            data: {{ resource_name | pascal_case }}Data {
                {% for field in fields %}
                {{ field.name | snake_case }}: {% if field.optional | default(value=false) %}None{% else %}Default::default(){% endif %},
                {% endfor %}
            },
            metadata: {{ resource_name | pascal_case }}Metadata {
                last_modified: None,
                etag: None,
                size_bytes: None,
            },
        };

        let result = serialize_content(&content, "application/unsupported");
        assert!(result.is_err());
    }

    // # frozen id="custom_tests"
    // Add custom tests here - they will be preserved during regeneration
    // # end frozen
}
