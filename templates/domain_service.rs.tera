---
to: "generated/services/{{ service_name | snake_case }}.rs"
vars:
  service_name: string
  description: string
  has_async: boolean
  has_transactions: boolean
  has_events: boolean
  entity_name: string
  operations: array
  dependencies: array
---
{#- Validate required variables - ensure service_name and entity_name are provided -#}
{%- if not service_name -%}
{# ERROR: service_name is required for domain service generation -#}
//! ERROR: Missing required variable 'service_name'
{%- elif not entity_name -%}
{# ERROR: entity_name is required for domain service generation -#}
//! ERROR: Missing required variable 'entity_name'
{%- else -%}
//! Domain Service: {{ service_name | pascal_case }}
//!
//! {{ description }}
//!
//! Entity: {{ entity_name | pascal_case }}
//! Generated by ggen from ontology specification
//!
//! IMPORTANT: Sections marked with `# frozen` / `# end frozen` preserve your
//! custom code during regeneration. Edit only within frozen sections.

use anyhow::{Result, Context, anyhow};
{% if has_async %}
use async_trait::async_trait;
{% endif %}
use std::sync::Arc;
use thiserror::Error;

{% for dep in dependencies %}
use crate::{{ dep.module }}::{{ dep.type }};
{% endfor %}
use crate::domain::{{ entity_name | snake_case }}::{{ entity_name | pascal_case }};

// ============================================================================
// ERROR TYPES
// ============================================================================

/// Errors from {{ service_name | pascal_case }} operations
#[derive(Debug, Error)]
pub enum {{ service_name | pascal_case }}Error {
    #[error("entity not found: {0}")]
    NotFound(String),

    #[error("validation failed: {0}")]
    ValidationFailed(String),

    #[error("operation failed: {0}")]
    OperationFailed(String),

    {% if has_transactions %}
    #[error("transaction failed: {0}")]
    TransactionFailed(String),

    #[error("concurrency conflict: {0}")]
    ConcurrencyConflict(String),
    {% endif %}

    #[error("internal error: {0}")]
    Internal(#[from] anyhow::Error),

    // # frozen id="custom_errors"
    // Add custom error variants here - they will be preserved during regeneration
    // # end frozen
}

pub type ServiceResult<T> = std::result::Result<T, {{ service_name | pascal_case }}Error>;

// ============================================================================
// SERVICE TRAIT
// ============================================================================

/// {{ description }}
///
/// This trait defines the contract for {{ service_name | snake_case }} operations.
/// Implementations may vary (e.g., in-memory, database-backed, distributed).
{% if has_async %}
#[async_trait]
{% endif %}
pub trait {{ service_name | pascal_case }}: Send + Sync {
    {% for op in operations %}
    /// {{ op.description | default(value="Perform operation") }}
    {% if has_async %}
    async fn {{ op.name | snake_case }}(
    {% else %}
    fn {{ op.name | snake_case }}(
    {% endif %}
        &self,
        {% for param in op.params | default(value=[]) %}
        {{ param.name | snake_case }}: {{ param.rust_type | default(value="String") }},
        {% endfor %}
    ) -> ServiceResult<{{ op.return_type | default(value="()") }}>;

    {% endfor %}

    // # frozen id="additional_operations"
    // Add custom operations here - they will be preserved during regeneration
    // # end frozen
}

{% if has_events %}
// ============================================================================
// DOMAIN EVENTS
// ============================================================================

/// Events emitted by {{ service_name | pascal_case }}
#[derive(Debug, Clone)]
pub enum {{ service_name | pascal_case }}Event {
    {% for op in operations %}
    {% if op.emits_event | default(value=false) %}
    /// Event emitted after {{ op.name | snake_case }} operation
    {{ op.name | pascal_case }}Completed {
        {% for param in op.params | default(value=[]) %}
        {{ param.name | snake_case }}: {{ param.rust_type | default(value="String") }},
        {% endfor %}
        timestamp: chrono::DateTime<chrono::Utc>,
    },
    {% endif %}
    {% endfor %}

    // # frozen id="custom_events"
    // Add custom events here - they will be preserved during regeneration
    // # end frozen
}

/// Event handler trait for {{ service_name | pascal_case }} events
{% if has_async %}
#[async_trait]
{% endif %}
pub trait {{ service_name | pascal_case }}EventHandler: Send + Sync {
    {% if has_async %}
    async fn handle(&self, event: {{ service_name | pascal_case }}Event) -> Result<()>;
    {% else %}
    fn handle(&self, event: {{ service_name | pascal_case }}Event) -> Result<()>;
    {% endif %}
}

/// No-op event handler for testing or when events are not needed
pub struct NoOp{{ service_name | pascal_case }}EventHandler;

{% if has_async %}
#[async_trait]
{% endif %}
impl {{ service_name | pascal_case }}EventHandler for NoOp{{ service_name | pascal_case }}EventHandler {
    {% if has_async %}
    async fn handle(&self, _event: {{ service_name | pascal_case }}Event) -> Result<()> {
    {% else %}
    fn handle(&self, _event: {{ service_name | pascal_case }}Event) -> Result<()> {
    {% endif %}
        Ok(())
    }
}
{% endif %}

{% if has_transactions %}
// ============================================================================
// UNIT OF WORK
// ============================================================================

/// Transaction/Unit of Work abstraction for {{ service_name | pascal_case }}
{% if has_async %}
#[async_trait]
{% endif %}
pub trait {{ service_name | pascal_case }}UnitOfWork: Send + Sync {
    /// Begin a new transaction
    {% if has_async %}
    async fn begin(&self) -> ServiceResult<Box<dyn {{ service_name | pascal_case }}Transaction>>;
    {% else %}
    fn begin(&self) -> ServiceResult<Box<dyn {{ service_name | pascal_case }}Transaction>>;
    {% endif %}
}

/// Active transaction handle
{% if has_async %}
#[async_trait]
{% endif %}
pub trait {{ service_name | pascal_case }}Transaction: Send + Sync {
    /// Commit the transaction
    {% if has_async %}
    async fn commit(self: Box<Self>) -> ServiceResult<()>;
    {% else %}
    fn commit(self: Box<Self>) -> ServiceResult<()>;
    {% endif %}

    /// Rollback the transaction
    {% if has_async %}
    async fn rollback(self: Box<Self>) -> ServiceResult<()>;
    {% else %}
    fn rollback(self: Box<Self>) -> ServiceResult<()>;
    {% endif %}

    /// Access the service within the transaction
    fn service(&self) -> &dyn {{ service_name | pascal_case }};
}
{% endif %}

// ============================================================================
// DEFAULT IMPLEMENTATION
// ============================================================================

/// Default implementation of {{ service_name | pascal_case }}
pub struct {{ service_name | pascal_case }}Impl {
    {% for dep in dependencies %}
    {{ dep.name | snake_case }}: Arc<dyn {{ dep.type }}>,
    {% endfor %}
    {% if has_events %}
    event_handler: Arc<dyn {{ service_name | pascal_case }}EventHandler>,
    {% endif %}

    // # frozen id="impl_fields"
    // Add custom fields here - they will be preserved during regeneration
    // # end frozen
}

impl {{ service_name | pascal_case }}Impl {
    /// Create a new {{ service_name | pascal_case }} instance
    pub fn new(
        {% for dep in dependencies %}
        {{ dep.name | snake_case }}: Arc<dyn {{ dep.type }}>,
        {% endfor %}
        {% if has_events %}
        event_handler: Arc<dyn {{ service_name | pascal_case }}EventHandler>,
        {% endif %}
    ) -> Self {
        Self {
            {% for dep in dependencies %}
            {{ dep.name | snake_case }},
            {% endfor %}
            {% if has_events %}
            event_handler,
            {% endif %}
        }
    }

    // # frozen id="helper_methods"
    // Add private helper methods here - they will be preserved during regeneration
    // # end frozen
}

{% if has_async %}
#[async_trait]
{% endif %}
impl {{ service_name | pascal_case }} for {{ service_name | pascal_case }}Impl {
    {% for op in operations %}
    {% if has_async %}
    async fn {{ op.name | snake_case }}(
    {% else %}
    fn {{ op.name | snake_case }}(
    {% endif %}
        &self,
        {% for param in op.params | default(value=[]) %}
        {{ param.name | snake_case }}: {{ param.rust_type | default(value="String") }},
        {% endfor %}
    ) -> ServiceResult<{{ op.return_type | default(value="()") }}> {
        // # frozen id="{{ op.name | snake_case }}_impl"
        // Implement {{ op.name | snake_case }} logic here - it will be preserved during regeneration
        //
        // Example:
        // let entity = self.repository.find(&id).await?
        //     .ok_or_else(|| {{ service_name | pascal_case }}Error::NotFound(id.clone()))?;
        //
        // // Perform operation...
        //
        {% if has_events and op.emits_event | default(value=false) %}
        // // Emit event
        // let event = {{ service_name | pascal_case }}Event::{{ op.name | pascal_case }}Completed {
        //     {% for param in op.params | default(value=[]) %}
        //     {{ param.name | snake_case }},
        //     {% endfor %}
        //     timestamp: chrono::Utc::now(),
        // };
        // self.event_handler.handle(event).await?;
        {% endif %}
        //
        // Ok(result)

        {% for param in op.params | default(value=[]) %}
        let _ = {{ param.name | snake_case }};
        {% endfor %}
        unimplemented!("Implement {{ op.name | snake_case }} - see frozen section for example")
        // # end frozen
    }

    {% endfor %}
}

// ============================================================================
// BUILDER
// ============================================================================

/// Builder for {{ service_name | pascal_case }}Impl
#[derive(Default)]
pub struct {{ service_name | pascal_case }}Builder {
    {% for dep in dependencies %}
    {{ dep.name | snake_case }}: Option<Arc<dyn {{ dep.type }}>>,
    {% endfor %}
    {% if has_events %}
    event_handler: Option<Arc<dyn {{ service_name | pascal_case }}EventHandler>>,
    {% endif %}
}

impl {{ service_name | pascal_case }}Builder {
    /// Create a new builder
    pub fn new() -> Self {
        Self::default()
    }

    {% for dep in dependencies %}
    /// Set the {{ dep.name | snake_case }} dependency
    pub fn {{ dep.name | snake_case }}(mut self, {{ dep.name | snake_case }}: Arc<dyn {{ dep.type }}>) -> Self {
        self.{{ dep.name | snake_case }} = Some({{ dep.name | snake_case }});
        self
    }
    {% endfor %}

    {% if has_events %}
    /// Set the event handler
    pub fn event_handler(mut self, handler: Arc<dyn {{ service_name | pascal_case }}EventHandler>) -> Self {
        self.event_handler = Some(handler);
        self
    }
    {% endif %}

    /// Build the service instance
    pub fn build(self) -> Result<{{ service_name | pascal_case }}Impl> {
        Ok({{ service_name | pascal_case }}Impl::new(
            {% for dep in dependencies %}
            self.{{ dep.name | snake_case }}
                .ok_or_else(|| anyhow!("{{ dep.name | snake_case }} is required"))?,
            {% endfor %}
            {% if has_events %}
            self.event_handler
                .unwrap_or_else(|| Arc::new(NoOp{{ service_name | pascal_case }}EventHandler)),
            {% endif %}
        ))
    }
}

// ============================================================================
// TESTS
// ============================================================================

#[cfg(test)]
mod tests {
    use super::*;

    {% if has_async %}
    // Mock dependencies for testing
    {% for dep in dependencies %}
    struct Mock{{ dep.type }} {
        // # frozen id="mock_{{ dep.name | snake_case }}_fields"
        // Add mock state fields here - they will be preserved during regeneration
        // # end frozen
    }

    impl Mock{{ dep.type }} {
        fn new() -> Self {
            Self {
                // # frozen id="mock_{{ dep.name | snake_case }}_init"
                // Initialize mock state here - it will be preserved during regeneration
                // # end frozen
            }
        }
    }

    #[async_trait]
    impl {{ dep.type }} for Mock{{ dep.type }} {
        // # frozen id="mock_{{ dep.name | snake_case }}_impl"
        // Implement mock trait methods here - they will be preserved during regeneration
        // # end frozen
    }
    {% endfor %}

    #[tokio::test]
    async fn test_{{ service_name | snake_case }}_builder() {
        let service = {{ service_name | pascal_case }}Builder::new()
            {% for dep in dependencies %}
            .{{ dep.name | snake_case }}(Arc::new(Mock{{ dep.type }}::new()))
            {% endfor %}
            .build();

        assert!(service.is_ok());
    }

    {% for op in operations %}
    #[tokio::test]
    #[ignore = "requires implementation"]
    async fn test_{{ op.name | snake_case }}() {
        let service = {{ service_name | pascal_case }}Builder::new()
            {% for dep in dependencies %}
            .{{ dep.name | snake_case }}(Arc::new(Mock{{ dep.type }}::new()))
            {% endfor %}
            .build()
            .expect("should build service");

        // # frozen id="test_{{ op.name | snake_case }}"
        // Implement test for {{ op.name | snake_case }} here - it will be preserved during regeneration
        //
        // Arrange
        // let input = ...;
        //
        // Act
        // let result = service.{{ op.name | snake_case }}(input).await;
        //
        // Assert
        // assert!(result.is_ok());
        // # end frozen
    }
    {% endfor %}
    {% else %}
    #[test]
    fn test_{{ service_name | snake_case }}_builder() {
        let service = {{ service_name | pascal_case }}Builder::new()
            {% for dep in dependencies %}
            .{{ dep.name | snake_case }}(Arc::new(/* mock */))
            {% endfor %}
            .build();

        assert!(service.is_ok());
    }

    {% for op in operations %}
    #[test]
    #[ignore = "requires implementation"]
    fn test_{{ op.name | snake_case }}() {
        // # frozen id="test_{{ op.name | snake_case }}"
        // Implement test for {{ op.name | snake_case }} here - it will be preserved during regeneration
        // # end frozen
    }
    {% endfor %}
    {% endif %}

    // # frozen id="custom_tests"
    // Add custom tests here - they will be preserved during regeneration
    // # end frozen
}
