---
to: "generated/domain/{{ entity_name | snake_case }}.rs"
vars:
  entity_name: string
  description: string
  has_id: boolean
  has_timestamps: boolean
  has_validation: boolean
  has_builder: boolean
  fields: array
  invariants: array
---
{#- Validate required variables - ensure entity_name is provided -#}
{%- if not entity_name -%}
{# ERROR: entity_name is required for domain entity generation -#}
//! ERROR: Missing required variable 'entity_name'
{%- else -%}
//! {{ description }}
//!
//! Domain Entity: {{ entity_name | pascal_case }}
//! Generated by ggen from ontology specification
//!
//! IMPORTANT: Sections marked with `# frozen` / `# end frozen` preserve your
//! custom code during regeneration. Edit only within frozen sections.

use serde::{Deserialize, Serialize};
use std::fmt;
use thiserror::Error;

{% if has_timestamps %}
use chrono::{DateTime, Utc};
{% endif %}

// ============================================================================
// ERROR TYPES
// ============================================================================

/// Validation errors for {{ entity_name | pascal_case }}
#[derive(Debug, Error, Clone, PartialEq, Eq)]
pub enum {{ entity_name | pascal_case }}Error {
    #[error("validation failed: {0}")]
    ValidationFailed(String),

    #[error("invariant violated: {0}")]
    InvariantViolation(String),

    {% if has_id %}
    #[error("invalid ID: {0}")]
    InvalidId(String),
    {% endif %}

    // # frozen id="custom_errors"
    // Add custom error variants here - they will be preserved during regeneration
    // # end frozen
}

pub type Result<T> = std::result::Result<T, {{ entity_name | pascal_case }}Error>;

// ============================================================================
// ENTITY DEFINITION
// ============================================================================

{% if has_id %}
/// Unique identifier type for {{ entity_name | pascal_case }}
pub type {{ entity_name | pascal_case }}Id = String;
{% endif %}

/// {{ description }}
///
/// This is a domain entity with enforced invariants.
/// All mutations go through validated methods to maintain consistency.
#[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize)]
pub struct {{ entity_name | pascal_case }} {
    {% if has_id %}
    /// Unique identifier
    id: {{ entity_name | pascal_case }}Id,
    {% endif %}
    {% for field in fields %}
    /// {{ field.description | default(value="Field") }}
    {{ field.name | snake_case }}: {{ field.rust_type | default(value="String") }},
    {% endfor %}
    {% if has_timestamps %}
    /// Creation timestamp
    created_at: DateTime<Utc>,
    /// Last modification timestamp
    updated_at: DateTime<Utc>,
    {% endif %}

    // # frozen id="additional_fields"
    // Add custom fields here - they will be preserved during regeneration
    // # end frozen
}

// ============================================================================
// ENTITY IMPLEMENTATION
// ============================================================================

impl {{ entity_name | pascal_case }} {
    /// Creates a new {{ entity_name | pascal_case }} with validation
    pub fn new(
        {% if has_id %}
        id: impl Into<{{ entity_name | pascal_case }}Id>,
        {% endif %}
        {% for field in fields %}
        {{ field.name | snake_case }}: impl Into<{{ field.rust_type | default(value="String") }}>,
        {% endfor %}
    ) -> Result<Self> {
        let instance = Self {
            {% if has_id %}
            id: id.into(),
            {% endif %}
            {% for field in fields %}
            {{ field.name | snake_case }}: {{ field.name | snake_case }}.into(),
            {% endfor %}
            {% if has_timestamps %}
            created_at: Utc::now(),
            updated_at: Utc::now(),
            {% endif %}
        };

        {% if has_validation %}
        instance.validate()?;
        {% endif %}

        Ok(instance)
    }

    {% if has_id %}
    /// Returns the entity's unique identifier
    pub fn id(&self) -> &{{ entity_name | pascal_case }}Id {
        &self.id
    }
    {% endif %}

    {% for field in fields %}
    /// Returns the {{ field.name | snake_case }} field
    pub fn {{ field.name | snake_case }}(&self) -> &{{ field.rust_type | default(value="String") }} {
        &self.{{ field.name | snake_case }}
    }

    /// Sets the {{ field.name | snake_case }} field with validation
    pub fn set_{{ field.name | snake_case }}(&mut self, value: impl Into<{{ field.rust_type | default(value="String") }}>) -> Result<()> {
        self.{{ field.name | snake_case }} = value.into();
        {% if has_timestamps %}
        self.updated_at = Utc::now();
        {% endif %}
        {% if has_validation %}
        self.validate()?;
        {% endif %}
        Ok(())
    }
    {% endfor %}

    {% if has_timestamps %}
    /// Returns the creation timestamp
    pub fn created_at(&self) -> DateTime<Utc> {
        self.created_at
    }

    /// Returns the last update timestamp
    pub fn updated_at(&self) -> DateTime<Utc> {
        self.updated_at
    }
    {% endif %}

    {% if has_validation %}
    /// Validates all invariants for this entity
    pub fn validate(&self) -> Result<()> {
        {% if has_id %}
        // ID validation
        if self.id.is_empty() {
            return Err({{ entity_name | pascal_case }}Error::InvalidId(
                "ID cannot be empty".to_string(),
            ));
        }
        {% endif %}

        {% for field in fields %}
        {% if field.required | default(value=true) %}
        // {{ field.name }} required validation
        {% if field.rust_type | default(value="String") == "String" %}
        if self.{{ field.name | snake_case }}.is_empty() {
            return Err({{ entity_name | pascal_case }}Error::ValidationFailed(
                "{{ field.name | snake_case }} cannot be empty".to_string(),
            ));
        }
        {% endif %}
        {% endif %}
        {% endfor %}

        {% for invariant in invariants %}
        // Invariant: {{ invariant.description | default(value="Custom invariant") }}
        if !({{ invariant.expression }}) {
            return Err({{ entity_name | pascal_case }}Error::InvariantViolation(
                "{{ invariant.message | default(value=invariant.expression) }}".to_string(),
            ));
        }
        {% endfor %}

        // # frozen id="custom_validation"
        // Add custom validation logic here - it will be preserved during regeneration
        // # end frozen

        Ok(())
    }
    {% endif %}

    // # frozen id="custom_methods"
    // Add custom methods here - they will be preserved during regeneration
    // # end frozen
}

impl fmt::Display for {{ entity_name | pascal_case }} {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        write!(
            f,
            "{{ entity_name | pascal_case }} {{ \"{\" }}{% if has_id %}id: {}{% endif %}{% for field in fields %}{% if has_id or not loop.first %}, {% endif %}{{ field.name | snake_case }}: {}{% endfor %}{{ \"}\" }}",
            {% if has_id %}
            self.id,
            {% endif %}
            {% for field in fields %}
            self.{{ field.name | snake_case }}{% if not loop.last %},{% endif %}
            {% endfor %}
        )
    }
}

{% if has_builder %}
// ============================================================================
// BUILDER PATTERN
// ============================================================================

/// Builder for {{ entity_name | pascal_case }}
#[derive(Debug, Default, Clone)]
pub struct {{ entity_name | pascal_case }}Builder {
    {% if has_id %}
    id: Option<{{ entity_name | pascal_case }}Id>,
    {% endif %}
    {% for field in fields %}
    {{ field.name | snake_case }}: Option<{{ field.rust_type | default(value="String") }}>,
    {% endfor %}
}

impl {{ entity_name | pascal_case }}Builder {
    /// Creates a new builder
    pub fn new() -> Self {
        Self::default()
    }

    {% if has_id %}
    /// Sets the ID
    pub fn id(mut self, id: impl Into<{{ entity_name | pascal_case }}Id>) -> Self {
        self.id = Some(id.into());
        self
    }
    {% endif %}

    {% for field in fields %}
    /// Sets the {{ field.name | snake_case }} field
    pub fn {{ field.name | snake_case }}(mut self, value: impl Into<{{ field.rust_type | default(value="String") }}>) -> Self {
        self.{{ field.name | snake_case }} = Some(value.into());
        self
    }
    {% endfor %}

    /// Builds the {{ entity_name | pascal_case }}, returning an error if required fields are missing
    pub fn build(self) -> Result<{{ entity_name | pascal_case }}> {
        {{ entity_name | pascal_case }}::new(
            {% if has_id %}
            self.id.ok_or_else(|| {{ entity_name | pascal_case }}Error::ValidationFailed("id is required".to_string()))?,
            {% endif %}
            {% for field in fields %}
            self.{{ field.name | snake_case }}.ok_or_else(|| {{ entity_name | pascal_case }}Error::ValidationFailed("{{ field.name | snake_case }} is required".to_string()))?{% if not loop.last %},{% endif %}
            {% endfor %}
        )
    }

    // # frozen id="builder_methods"
    // Add custom builder methods here - they will be preserved during regeneration
    // # end frozen
}

impl From<{{ entity_name | pascal_case }}> for {{ entity_name | pascal_case }}Builder {
    fn from(entity: {{ entity_name | pascal_case }}) -> Self {
        Self {
            {% if has_id %}
            id: Some(entity.id),
            {% endif %}
            {% for field in fields %}
            {{ field.name | snake_case }}: Some(entity.{{ field.name | snake_case }}),
            {% endfor %}
        }
    }
}
{% endif %}

// ============================================================================
// TESTS
// ============================================================================

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_new_{{ entity_name | snake_case }}_valid() {
        let result = {{ entity_name | pascal_case }}::new(
            {% if has_id %}
            "test-id-123",
            {% endif %}
            {% for field in fields %}
            "test_{{ field.name | snake_case }}"{% if not loop.last %},{% endif %}
            {% endfor %}
        );
        assert!(result.is_ok());
    }

    {% if has_id %}
    #[test]
    fn test_{{ entity_name | snake_case }}_empty_id_fails() {
        let result = {{ entity_name | pascal_case }}::new(
            "",
            {% for field in fields %}
            "test_value"{% if not loop.last %},{% endif %}
            {% endfor %}
        );
        {% if has_validation %}
        assert!(matches!(result, Err({{ entity_name | pascal_case }}Error::InvalidId(_))));
        {% endif %}
    }
    {% endif %}

    {% if has_builder %}
    #[test]
    fn test_{{ entity_name | snake_case }}_builder_success() {
        let result = {{ entity_name | pascal_case }}Builder::new()
            {% if has_id %}
            .id("builder-id-456")
            {% endif %}
            {% for field in fields %}
            .{{ field.name | snake_case }}("builder_{{ field.name | snake_case }}")
            {% endfor %}
            .build();
        assert!(result.is_ok());
    }

    #[test]
    fn test_{{ entity_name | snake_case }}_builder_missing_required() {
        let result = {{ entity_name | pascal_case }}Builder::new().build();
        assert!(result.is_err());
    }
    {% endif %}

    #[test]
    fn test_{{ entity_name | snake_case }}_display() {
        let entity = {{ entity_name | pascal_case }}::new(
            {% if has_id %}
            "display-id",
            {% endif %}
            {% for field in fields %}
            "display_{{ field.name | snake_case }}"{% if not loop.last %},{% endif %}
            {% endfor %}
        ).expect("should create entity");

        let display = format!("{}", entity);
        assert!(display.contains("{{ entity_name | pascal_case }}"));
    }

    // # frozen id="custom_tests"
    // Add custom tests here - they will be preserved during regeneration
    // # end frozen
}
