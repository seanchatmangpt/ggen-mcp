---
to: "generated/tools/{{ tool_name | snake_case }}.rs"
vars:
  tool_name: string
  description: string
  category: string
  has_params: boolean
  has_pagination: boolean
  has_filters: boolean
  params: array
  response_fields: array
---
{#- Validate required variables - ensure tool_name is provided -#}
{%- if not tool_name -%}
{# ERROR: tool_name is required for tool handler generation -#}
//! ERROR: Missing required variable 'tool_name'
{%- else -%}
//! MCP Tool Handler: {{ tool_name | snake_case }}
//!
//! {{ description }}
//!
//! Category: {{ category | default(value="general") }}
//! Generated by ggen from ontology specification
//!
//! IMPORTANT: Sections marked with `# frozen` / `# end frozen` preserve your
//! custom code during regeneration. Edit only within frozen sections.

use anyhow::{Result, Context, anyhow};
use serde::{Deserialize, Serialize};
use std::sync::Arc;
use crate::state::AppState;

{% if has_pagination %}
const DEFAULT_LIMIT: usize = 100;
const MAX_LIMIT: usize = 1000;
{% endif %}

// ============================================================================
// PARAMETERS
// ============================================================================

/// Parameters for the {{ tool_name | snake_case }} tool
#[derive(Debug, Clone, Deserialize)]
#[serde(deny_unknown_fields)]
pub struct {{ tool_name | pascal_case }}Params {
    {% for param in params %}
    /// {{ param.description | default(value="Parameter") }}
    {% if param.required | default(value=false) %}
    pub {{ param.name | snake_case }}: {{ param.rust_type | default(value="String") }},
    {% else %}
    #[serde(default{% if param.default %} = "default_{{ param.name | snake_case }}"{% endif %})]
    pub {{ param.name | snake_case }}: {% if param.rust_type | default(value="String") contains "Option" %}{{ param.rust_type }}{% else %}Option<{{ param.rust_type | default(value="String") }}>{% endif %},
    {% endif %}
    {% endfor %}

    {% if has_pagination %}
    /// Maximum number of results to return (default: {{ "100" }}, max: {{ "1000" }})
    #[serde(default = "default_limit")]
    pub limit: usize,

    /// Number of results to skip for pagination
    #[serde(default)]
    pub offset: usize,
    {% endif %}

    {% if has_filters %}
    /// Filter criteria for results
    #[serde(default)]
    pub filters: Option<{{ tool_name | pascal_case }}Filters>,
    {% endif %}

    // # frozen id="additional_params"
    // Add custom parameters here - they will be preserved during regeneration
    // # end frozen
}

{% if has_pagination %}
fn default_limit() -> usize {
    DEFAULT_LIMIT
}
{% endif %}

{% for param in params %}
{% if param.default and not param.required | default(value=false) %}
fn default_{{ param.name | snake_case }}() -> {% if param.rust_type | default(value="String") contains "Option" %}{{ param.rust_type }}{% else %}Option<{{ param.rust_type | default(value="String") }}>{% endif %} {
    Some({{ param.default }})
}
{% endif %}
{% endfor %}

{% if has_filters %}
/// Filter criteria for {{ tool_name | snake_case }}
#[derive(Debug, Clone, Default, Deserialize)]
#[serde(deny_unknown_fields)]
pub struct {{ tool_name | pascal_case }}Filters {
    {% for param in params %}
    {% if param.filterable | default(value=false) %}
    /// Filter by {{ param.name | snake_case }}
    pub {{ param.name | snake_case }}: Option<{{ param.rust_type | default(value="String") }}>,
    {% endif %}
    {% endfor %}

    // # frozen id="additional_filters"
    // Add custom filters here - they will be preserved during regeneration
    // # end frozen
}
{% endif %}

// ============================================================================
// RESPONSE
// ============================================================================

/// Response from the {{ tool_name | snake_case }} tool
#[derive(Debug, Clone, Serialize)]
pub struct {{ tool_name | pascal_case }}Response {
    {% for field in response_fields %}
    /// {{ field.description | default(value="Response field") }}
    pub {{ field.name | snake_case }}: {{ field.rust_type | default(value="String") }},
    {% endfor %}

    {% if has_pagination %}
    /// Total number of available results (before pagination)
    pub total_count: usize,

    /// Number of results returned in this response
    pub returned_count: usize,

    /// Whether there are more results available
    pub has_more: bool,
    {% endif %}

    /// Execution metadata
    pub metadata: {{ tool_name | pascal_case }}Metadata,

    // # frozen id="additional_response_fields"
    // Add custom response fields here - they will be preserved during regeneration
    // # end frozen
}

/// Metadata about tool execution
#[derive(Debug, Clone, Serialize)]
pub struct {{ tool_name | pascal_case }}Metadata {
    /// Tool execution duration in milliseconds
    pub duration_ms: u64,

    /// Tool version
    pub tool_version: String,

    // # frozen id="additional_metadata"
    // Add custom metadata fields here - they will be preserved during regeneration
    // # end frozen
}

// ============================================================================
// TOOL IMPLEMENTATION
// ============================================================================

/// Execute the {{ tool_name | snake_case }} tool
///
/// {{ description }}
///
/// # Arguments
/// * `state` - Application state with shared resources
/// * `params` - Tool parameters
///
/// # Returns
/// * `Result<{{ tool_name | pascal_case }}Response>` - Tool response or error
///
/// # Errors
/// * Returns error if validation fails
/// * Returns error if underlying operation fails
pub async fn {{ tool_name | snake_case }}(
    state: Arc<AppState>,
    params: {{ tool_name | pascal_case }}Params,
) -> Result<{{ tool_name | pascal_case }}Response> {
    let start = std::time::Instant::now();

    // Validate parameters
    validate_params(&params)?;

    {% if has_pagination %}
    // Apply pagination limits
    let limit = params.limit.min(MAX_LIMIT);
    let offset = params.offset;
    {% endif %}

    // # frozen id="pre_execution"
    // Add custom pre-execution logic here - it will be preserved during regeneration
    // # end frozen

    // Execute the core tool logic
    let result = execute_{{ tool_name | snake_case }}_impl(
        state,
        &params,
        {% if has_pagination %}
        limit,
        offset,
        {% endif %}
    ).await?;

    // # frozen id="post_execution"
    // Add custom post-execution logic here - it will be preserved during regeneration
    // # end frozen

    let duration_ms = start.elapsed().as_millis() as u64;

    Ok({{ tool_name | pascal_case }}Response {
        {% for field in response_fields %}
        {{ field.name | snake_case }}: result.{{ field.name | snake_case }},
        {% endfor %}
        {% if has_pagination %}
        total_count: result.total_count,
        returned_count: result.items.len(),
        has_more: offset + result.items.len() < result.total_count,
        {% endif %}
        metadata: {{ tool_name | pascal_case }}Metadata {
            duration_ms,
            tool_version: env!("CARGO_PKG_VERSION").to_string(),
        },
    })
}

/// Validate tool parameters
fn validate_params(params: &{{ tool_name | pascal_case }}Params) -> Result<()> {
    {% for param in params %}
    {% if param.required | default(value=false) %}
    {% if param.rust_type | default(value="String") == "String" %}
    // Validate required {{ param.name | snake_case }}
    if params.{{ param.name | snake_case }}.is_empty() {
        return Err(anyhow!("{{ param.name | snake_case }} is required and cannot be empty"));
    }
    {% endif %}
    {% endif %}
    {% endfor %}

    {% if has_pagination %}
    // Validate pagination
    if params.limit == 0 {
        return Err(anyhow!("limit must be greater than 0"));
    }
    if params.limit > MAX_LIMIT {
        return Err(anyhow!("limit cannot exceed {}", MAX_LIMIT));
    }
    {% endif %}

    // # frozen id="custom_validation"
    // Add custom parameter validation here - it will be preserved during regeneration
    // # end frozen

    Ok(())
}

/// Internal result type for execution
#[derive(Debug)]
struct ExecutionResult {
    {% for field in response_fields %}
    {{ field.name | snake_case }}: {{ field.rust_type | default(value="String") }},
    {% endfor %}
    {% if has_pagination %}
    items: Vec<{{ tool_name | pascal_case }}Item>,
    total_count: usize,
    {% endif %}
}

{% if has_pagination %}
/// Individual item in paginated results
#[derive(Debug, Clone, Serialize)]
pub struct {{ tool_name | pascal_case }}Item {
    // # frozen id="item_fields"
    // Define item fields here - they will be preserved during regeneration
    pub id: String,
    // # end frozen
}
{% endif %}

/// Core implementation of {{ tool_name | snake_case }}
async fn execute_{{ tool_name | snake_case }}_impl(
    _state: Arc<AppState>,
    _params: &{{ tool_name | pascal_case }}Params,
    {% if has_pagination %}
    _limit: usize,
    _offset: usize,
    {% endif %}
) -> Result<ExecutionResult> {
    // # frozen id="implementation"
    // Implement the core tool logic here - it will be preserved during regeneration
    //
    // Example implementation:
    // let data = state.some_service().do_something(&params.some_param).await?;
    //
    // return Ok(ExecutionResult {
    //     field_name: data.into(),
    //     {% if has_pagination %}items: vec![], total_count: 0,{% endif %}
    // });

    unimplemented!("Implement {{ tool_name | snake_case }} tool logic - see frozen section for example")
    // # end frozen
}

// ============================================================================
// TESTS
// ============================================================================

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_{{ tool_name | snake_case }}_params_deserialize() {
        let json = r#"{
            {% for param in params %}
            {% if param.required | default(value=false) %}
            "{{ param.name | snake_case }}": "test_value"{% if not loop.last %},{% endif %}
            {% endif %}
            {% endfor %}
        }"#;

        let params: Result<{{ tool_name | pascal_case }}Params, _> = serde_json::from_str(json);
        assert!(params.is_ok(), "Should deserialize valid params");
    }

    {% for param in params %}
    {% if param.required | default(value=false) and param.rust_type | default(value="String") == "String" %}
    #[test]
    fn test_{{ tool_name | snake_case }}_validate_empty_{{ param.name | snake_case }}() {
        let params = {{ tool_name | pascal_case }}Params {
            {{ param.name | snake_case }}: String::new(),
            {% for other_param in params %}
            {% if other_param.name != param.name %}
            {% if other_param.required | default(value=false) %}
            {{ other_param.name | snake_case }}: "test".to_string(),
            {% else %}
            {{ other_param.name | snake_case }}: None,
            {% endif %}
            {% endif %}
            {% endfor %}
            {% if has_pagination %}
            limit: DEFAULT_LIMIT,
            offset: 0,
            {% endif %}
            {% if has_filters %}
            filters: None,
            {% endif %}
        };

        let result = validate_params(&params);
        assert!(result.is_err(), "Should fail with empty {{ param.name | snake_case }}");
    }
    {% endif %}
    {% endfor %}

    {% if has_pagination %}
    #[test]
    fn test_{{ tool_name | snake_case }}_validate_pagination() {
        let params = {{ tool_name | pascal_case }}Params {
            {% for param in params %}
            {% if param.required | default(value=false) %}
            {{ param.name | snake_case }}: "test".to_string(),
            {% else %}
            {{ param.name | snake_case }}: None,
            {% endif %}
            {% endfor %}
            limit: 0,
            offset: 0,
            {% if has_filters %}
            filters: None,
            {% endif %}
        };

        let result = validate_params(&params);
        assert!(result.is_err(), "Should fail with limit=0");
    }

    #[test]
    fn test_{{ tool_name | snake_case }}_validate_max_limit() {
        let params = {{ tool_name | pascal_case }}Params {
            {% for param in params %}
            {% if param.required | default(value=false) %}
            {{ param.name | snake_case }}: "test".to_string(),
            {% else %}
            {{ param.name | snake_case }}: None,
            {% endif %}
            {% endfor %}
            limit: MAX_LIMIT + 1,
            offset: 0,
            {% if has_filters %}
            filters: None,
            {% endif %}
        };

        let result = validate_params(&params);
        assert!(result.is_err(), "Should fail when limit exceeds MAX_LIMIT");
    }
    {% endif %}

    #[test]
    fn test_{{ tool_name | snake_case }}_response_serialize() {
        let response = {{ tool_name | pascal_case }}Response {
            {% for field in response_fields %}
            {{ field.name | snake_case }}: Default::default(),
            {% endfor %}
            {% if has_pagination %}
            total_count: 100,
            returned_count: 50,
            has_more: true,
            {% endif %}
            metadata: {{ tool_name | pascal_case }}Metadata {
                duration_ms: 42,
                tool_version: "1.0.0".to_string(),
            },
        };

        let json = serde_json::to_string(&response);
        assert!(json.is_ok(), "Should serialize response");
    }

    // # frozen id="custom_tests"
    // Add custom tests here - they will be preserved during regeneration
    // # end frozen
}
