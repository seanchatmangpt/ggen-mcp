//! User aggregate root for managing user accounts
//!
//! Domain Entity: User
//! Generated by ggen from ontology specification
//!
//! IMPORTANT: Sections marked with `# frozen` / `# end frozen` preserve your
//! custom code during regeneration. Edit only within frozen sections.

use serde::{Deserialize, Serialize};
use std::fmt;
use thiserror::Error;

use chrono::{DateTime, Utc};

// ============================================================================
// ERROR TYPES
// ============================================================================

/// Validation errors for User
#[derive(Debug, Error, Clone, PartialEq, Eq)]
pub enum UserError {
    #[error("validation failed: {0}")]
    ValidationFailed(String),

    #[error("invariant violated: {0}")]
    InvariantViolation(String),

    #[error("invalid ID: {0}")]
    InvalidId(String),

    // # frozen id="custom_errors"
    // Add custom error variants here - they will be preserved during regeneration
    // # end frozen
}

pub type Result<T> = std::result::Result<T, UserError>;

// ============================================================================
// ENTITY DEFINITION
// ============================================================================

/// Unique identifier type for User
pub type UserId = String;

/// User aggregate root for managing user accounts
///
/// This is a domain entity with enforced invariants.
/// All mutations go through validated methods to maintain consistency.
#[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize)]
pub struct User {
    /// Unique identifier
    id: UserId,
    /// Unique username for the user
    username: String,
    /// Email address for the user
    email: String,
    /// Full display name
    full_name: String,
    /// Creation timestamp
    created_at: DateTime<Utc>,
    /// Last modification timestamp
    updated_at: DateTime<Utc>,

    // # frozen id="additional_fields"
    // Add custom fields here - they will be preserved during regeneration
    // # end frozen
}

// ============================================================================
// ENTITY IMPLEMENTATION
// ============================================================================

impl User {
    /// Creates a new User with validation
    pub fn new(
        id: impl Into<UserId>,
        username: impl Into<String>,
        email: impl Into<String>,
        full_name: impl Into<String>,
    ) -> Result<Self> {
        let instance = Self {
            id: id.into(),
            username: username.into(),
            email: email.into(),
            full_name: full_name.into(),
            created_at: Utc::now(),
            updated_at: Utc::now(),
        };

        instance.validate()?;

        Ok(instance)
    }

    /// Returns the entity's unique identifier
    pub fn id(&self) -> &UserId {
        &self.id
    }

    /// Returns the username field
    pub fn username(&self) -> &String {
        &self.username
    }

    /// Sets the username field with validation
    pub fn set_username(&mut self, value: impl Into<String>) -> Result<()> {
        self.username = value.into();
        self.updated_at = Utc::now();
        self.validate()?;
        Ok(())
    }

    /// Returns the email field
    pub fn email(&self) -> &String {
        &self.email
    }

    /// Sets the email field with validation
    pub fn set_email(&mut self, value: impl Into<String>) -> Result<()> {
        self.email = value.into();
        self.updated_at = Utc::now();
        self.validate()?;
        Ok(())
    }

    /// Returns the full_name field
    pub fn full_name(&self) -> &String {
        &self.full_name
    }

    /// Sets the full_name field with validation
    pub fn set_full_name(&mut self, value: impl Into<String>) -> Result<()> {
        self.full_name = value.into();
        self.updated_at = Utc::now();
        self.validate()?;
        Ok(())
    }

    /// Returns the creation timestamp
    pub fn created_at(&self) -> DateTime<Utc> {
        self.created_at
    }

    /// Returns the last update timestamp
    pub fn updated_at(&self) -> DateTime<Utc> {
        self.updated_at
    }

    /// Validates all invariants for this entity
    pub fn validate(&self) -> Result<()> {
        // ID validation
        if self.id.is_empty() {
            return Err(UserError::InvalidId(
                "ID cannot be empty".to_string(),
            ));
        }

        // username required validation
        if self.username.is_empty() {
            return Err(UserError::ValidationFailed(
                "username cannot be empty".to_string(),
            ));
        }

        // email required validation
        if self.email.is_empty() {
            return Err(UserError::ValidationFailed(
                "email cannot be empty".to_string(),
            ));
        }

        // Invariant: Username must be at least 3 characters
        if !(self.username.len() >= 3) {
            return Err(UserError::InvariantViolation(
                "Username must be at least 3 characters long".to_string(),
            ));
        }

        // Invariant: Email must contain @ symbol
        if !(self.email.contains('@')) {
            return Err(UserError::InvariantViolation(
                "Email must be a valid email address".to_string(),
            ));
        }

        // # frozen id="custom_validation"
        // Add custom validation logic here - it will be preserved during regeneration
        // # end frozen

        Ok(())
    }

    // # frozen id="custom_methods"
    // Add custom methods here - they will be preserved during regeneration
    // # end frozen
}

impl fmt::Display for User {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        write!(
            f,
            "User {{id: {}, username: {}, email: {}, full_name: {}}}",
            self.id,
            self.username,
            self.email,
            self.full_name
        )
    }
}
